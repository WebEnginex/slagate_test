// src/admin/services/buildsSupabaseService.ts
import { createClient } from '@supabase/supabase-js';
import {
  ValidationError,
  NotFoundError,
  ConflictError,
  NetworkError,
  handleSupabaseError,
  handleGenericError,
  logError
} from '../../../services/errors';
import { BuildValidator, type BuildData } from '../utils/buildValidator';

// Configuration Supabase avec fallback pour le d√©veloppement
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || 'https://zmjcebypuyjhwqzfmjib.supabase.co';
const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InptamNlYnlwdXlqaHdxemZtamliIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ2MjY5ODIsImV4cCI6MjA1MDIwMjk4Mn0.wKaxrMU2fB4U4tTR3QywqxLTYaiKM3LZCUwCUvBP1Fo';

console.log('üîß Configuration Supabase:', {
  url: supabaseUrl,
  hasKey: !!supabaseKey,
  envUrl: import.meta.env.VITE_SUPABASE_URL,
  envKey: import.meta.env.VITE_SUPABASE_ANON_KEY ? '‚úÖ' : '‚ùå'
});

if (!supabaseUrl || !supabaseKey) {
  throw new Error('Configuration Supabase manquante');
}

const supabase = createClient(supabaseUrl, supabaseKey);

/**
 * Configuration pour le retry automatique
 */
const RETRY_CONFIG = {
  maxRetries: 3,
  initialDelay: 1000, // 1 seconde
  maxDelay: 5000,     // 5 secondes
  backoffMultiplier: 2
};

/**
 * Service pour g√©rer les builds dans Supabase avec gestion d'erreurs robuste
 */
export class BuildsSupabaseService {
  
  /**
   * Ex√©cute une op√©ration avec retry automatique en cas d'erreur r√©seau
   */
  private async withRetry<T>(
    operation: () => Promise<T>,
    context: string,
    retryCount = 0
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      // Ne pas retry si ce n'est pas une erreur r√©seau
      if (!(error instanceof NetworkError) || retryCount >= RETRY_CONFIG.maxRetries) {
        throw error;
      }

      // Calculer le d√©lai avec backoff exponentiel
      const delay = Math.min(
        RETRY_CONFIG.initialDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, retryCount),
        RETRY_CONFIG.maxDelay
      );

      if (process.env.NODE_ENV === 'development') {
        console.log(`üîÑ Retry ${retryCount + 1}/${RETRY_CONFIG.maxRetries} pour ${context} dans ${delay}ms...`);
      }

      // Attendre avant de r√©essayer
      await new Promise(resolve => setTimeout(resolve, delay));

      // R√©essayer
      return this.withRetry(operation, context, retryCount + 1);
    }
  }
  
  /**
   * R√©cup√®re un chasseur par son ID avec gestion d'erreurs compl√®te
   */
  async getChasseur(chasseurId: number) {
    try {
      if (process.env.NODE_ENV === 'development') {
        console.log(`üîç R√©cup√©ration chasseur ${chasseurId}...`);
      }

      // Validation de l'ID
      if (!chasseurId || chasseurId <= 0) {
        throw new ValidationError(
          'ID de chasseur invalide',
          [`L'ID du chasseur doit √™tre un nombre positif (re√ßu: ${chasseurId})`]
        );
      }

      const operation = async () => {
        const { data, error } = await supabase
          .from('builds')
          .select('*')
          .eq('chasseur_id', chasseurId)
          .single();

        if (error) {
          // G√©rer le cas sp√©cifique "not found"
          if (error.code === 'PGRST116') {
            throw new NotFoundError(
              `Chasseur ${chasseurId} non trouv√©`,
              'Chasseur',
              chasseurId,
              error
            );
          }
          // Autres erreurs Supabase
          throw handleSupabaseError(error, `R√©cup√©ration chasseur ${chasseurId}`);
        }

        if (!data) {
          throw new NotFoundError(
            `Aucune donn√©e pour le chasseur ${chasseurId}`,
            'Chasseur',
            chasseurId
          );
        }

        if (process.env.NODE_ENV === 'development') {
          console.log(`‚úÖ Chasseur ${chasseurId} r√©cup√©r√©:`, data);
        }

        return data;
      };

      return await this.withRetry(
        operation,
        `getChasseur(${chasseurId})`,
        0
      );
      
    } catch (error) {
      const buildsError = handleGenericError(error, `R√©cup√©ration chasseur ${chasseurId}`);
      logError(buildsError, 'getChasseur');
      throw buildsError;
    }
  }

  /**
   * Sauvegarde un build pour un chasseur avec validation et gestion d'erreurs compl√®tes
   */
  async saveChasseurBuild(
    chasseurId: number,
    buildName: string,
    buildData: Record<string, unknown>,
    originalBuildName?: string
  ) {
    try {
      if (process.env.NODE_ENV === 'development') {
        console.log(`üíæ Sauvegarde build "${buildName}" pour chasseur ${chasseurId}...`);
      }

      // Validation du nom du build
      const nameValidation = BuildValidator.validateBuildName(buildName);
      if (!nameValidation.isValid) {
        throw new ValidationError(
          'Nom de build invalide',
          nameValidation.errors
        );
      }

      // Validation des donn√©es du build
      const dataValidation = BuildValidator.validateBuildData(buildData as BuildData);
      if (!dataValidation.isValid) {
        throw new ValidationError(
          'Donn√©es de build invalides',
          dataValidation.errors
        );
      }

      // Log des warnings sans bloquer
      if (dataValidation.warnings.length > 0 && process.env.NODE_ENV === 'development') {
        console.warn('‚ö†Ô∏è Avertissements:', dataValidation.warnings);
      }

      const operation = async () => {
        // 1. R√©cup√©rer les builds actuels du chasseur
        const chasseur = await this.getChasseur(chasseurId);
        
        // 2. Validation des donn√©es du chasseur
        const chasseurValidation = BuildValidator.validateChasseurData(
          chasseur.chasseur_id,
          chasseur.chasseur_nom,
          chasseur.element
        );
        
        if (!chasseurValidation.isValid) {
          throw new ValidationError(
            'Donn√©es du chasseur invalides',
            chasseurValidation.errors
          );
        }
        
        // 3. Gestion des builds_data vides/null et du renommage
        const existingBuildsData = chasseur.builds_data || {};
        const currentBuilds = { ...(existingBuildsData.builds || {}) };
        
        // Gestion du renommage
        if (originalBuildName && originalBuildName !== buildName) {
          if (!currentBuilds[originalBuildName]) {
            throw new NotFoundError(
              `Le build original "${originalBuildName}" n'existe pas`,
              'Build',
              originalBuildName
            );
          }
          delete currentBuilds[originalBuildName];
          if (process.env.NODE_ENV === 'development') {
            console.log(`üîÑ Renommage build: "${originalBuildName}" ‚Üí "${buildName}"`);
          }
        }
        
        // V√©rifier si le nouveau nom existe d√©j√† (sauf si c'est une mise √† jour du m√™me build)
        if (currentBuilds[buildName] && originalBuildName !== buildName) {
          throw new ValidationError(
            `Un build nomm√© "${buildName}" existe d√©j√† pour ce chasseur`,
            [`Choisissez un autre nom ou supprimez le build existant`]
          );
        }
        
        // 4. Cr√©er la structure mise √† jour
        const updatedBuilds = {
          ...existingBuildsData,
          builds: {
            ...currentBuilds,
            [buildName]: buildData
          }
        };

        // 5. Pr√©parer les donn√©es de mise √† jour
        const updateData = {
          builds_data: updatedBuilds,
          updated_at: new Date().toISOString(),
          version: chasseur.version + 1
        };

        // 6. Sauvegarder en base avec versioning (protection contre modifications concurrentes)
        const { data, error } = await supabase
          .from('builds')
          .update(updateData)
          .eq('chasseur_id', chasseurId)
          .eq('version', chasseur.version) // Optimistic locking
          .select()
          .single();

        if (error) {
          // Cas sp√©cifique : conflit de version
          if (error.code === 'PGRST116') {
            throw new ConflictError(
              'Le chasseur a √©t√© modifi√© par quelqu\'un d\'autre entre-temps',
              error
            );
          }
          throw handleSupabaseError(error, `Sauvegarde build ${buildName}`);
        }

        if (!data) {
          throw new Error('Aucune donn√©e retourn√©e apr√®s la sauvegarde');
        }

        if (process.env.NODE_ENV === 'development') {
          console.log(`‚úÖ Build "${buildName}" sauvegard√© pour chasseur ${chasseurId}`);
        }

        return data;
      };

      return await this.withRetry(
        operation,
        `saveChasseurBuild(${chasseurId}, "${buildName}")`,
        0
      );
      
    } catch (error) {
      const buildsError = handleGenericError(
        error,
        `Sauvegarde build "${buildName}" pour chasseur ${chasseurId}`
      );
      logError(buildsError, 'saveChasseurBuild');
      throw buildsError;
    }
  }

  /**
   * Supprime un build avec validation et gestion d'erreurs
   */
  async deleteChasseurBuild(chasseurId: number, buildName: string) {
    try {
      if (process.env.NODE_ENV === 'development') {
        console.log(`üóëÔ∏è Suppression build "${buildName}" pour chasseur ${chasseurId}...`);
      }

      // Validation du nom du build
      if (!buildName || buildName.trim().length === 0) {
        throw new ValidationError(
          'Nom de build invalide',
          ['Le nom du build ne peut pas √™tre vide']
        );
      }

      const operation = async () => {
        // R√©cup√©rer le chasseur
        const chasseur = await this.getChasseur(chasseurId);
        
        const existingBuildsData = chasseur.builds_data || {};
        const currentBuilds = { ...(existingBuildsData.builds || {}) };
        
        // V√©rifier que le build existe
        if (!currentBuilds[buildName]) {
          throw new NotFoundError(
            `Le build "${buildName}" n'existe pas pour ce chasseur`,
            'Build',
            buildName
          );
        }

        // V√©rifier qu'il reste au moins un autre build (optionnel - √† adapter selon vos r√®gles)
        const remainingBuilds = Object.keys(currentBuilds).filter(name => name !== buildName);
        if (remainingBuilds.length === 0 && process.env.NODE_ENV === 'development') {
          console.warn('‚ö†Ô∏è Suppression du dernier build pour ce chasseur');
        }

        // Supprimer le build
        delete currentBuilds[buildName];
        const updatedBuilds = { ...existingBuildsData, builds: currentBuilds };

        // Sauvegarder
        const { data, error } = await supabase
          .from('builds')
          .update({
            builds_data: updatedBuilds,
            updated_at: new Date().toISOString(),
            version: chasseur.version + 1
          })
          .eq('chasseur_id', chasseurId)
          .eq('version', chasseur.version)
          .select()
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new ConflictError(
              'Le chasseur a √©t√© modifi√© par quelqu\'un d\'autre entre-temps',
              error
            );
          }
          throw handleSupabaseError(error, `Suppression build ${buildName}`);
        }

        if (process.env.NODE_ENV === 'development') {
          console.log(`‚úÖ Build "${buildName}" supprim√© pour chasseur ${chasseurId}`);
        }

        return { success: true, data };
      };

      return await this.withRetry(
        operation,
        `deleteChasseurBuild(${chasseurId}, "${buildName}")`,
        0
      );

    } catch (error) {
      const buildsError = handleGenericError(
        error,
        `Suppression build "${buildName}" pour chasseur ${chasseurId}`
      );
      logError(buildsError, 'deleteChasseurBuild');
      throw buildsError;
    }
  }

  /**
   * R√©cup√®re tous les chasseurs avec gestion d'erreurs
   */
  async getAllChasseurs() {
    try {
      if (process.env.NODE_ENV === 'development') {
        console.log('üîç Tentative de r√©cup√©ration des chasseurs...');
      }

      const operation = async () => {
        const { data, error } = await supabase
          .from('builds')
          .select('chasseur_id, chasseur_nom, element, builds_data, updated_at')
          .order('chasseur_id');

        if (error) {
          throw handleSupabaseError(error, 'R√©cup√©ration de tous les chasseurs');
        }

        const chasseurs = data || [];

        if (process.env.NODE_ENV === 'development') {
          console.log(`‚úÖ ${chasseurs.length} chasseur(s) r√©cup√©r√©(s)`);
        }

        return chasseurs;
      };

      return await this.withRetry(
        operation,
        'getAllChasseurs()',
        0
      );
      
    } catch (error) {
      const buildsError = handleGenericError(error, 'R√©cup√©ration de tous les chasseurs');
      logError(buildsError, 'getAllChasseurs');
      throw buildsError;
    }
  }

  // Validation des donn√©es avant sauvegarde
  validateBuildData(buildData: Record<string, unknown>): string[] {
    const errors: string[] = [];

    if (!buildData.artefacts) {
      errors.push('Les artefacts sont requis');
    }

    if (!buildData.noyaux) {
      errors.push('Les noyaux sont requis');
    }

    if (!buildData.stats) {
      errors.push('Les stats sont requises');
    }

    if (!buildData.sets_bonus) {
      errors.push('Les sets bonus sont requis');
    } else {
      // Valider que les sets_bonus ont des IDs valides (pas 0)
      const setsBonus = buildData.sets_bonus as Array<{ id: number }>;
      if (Array.isArray(setsBonus)) {
        const invalidSets = setsBonus.filter(set => !set.id || set.id === 0);
        if (invalidSets.length > 0) {
          errors.push(`${invalidSets.length} set(s) bonus ont des IDs invalides - veuillez s√©lectionner des sets valides`);
        }
      }
    }

    // Validation des artefacts
    if (buildData.artefacts) {
      Object.entries(buildData.artefacts).forEach(([slot, artefact]: [string, Record<string, unknown>]) => {
        if (!artefact.id) {
          errors.push(`Artefact ${slot}: ID manquant`);
        }
        if (!artefact.statPrincipale) {
          errors.push(`Artefact ${slot}: Stat principale manquante`);
        }
      });
    }

    return errors;
  }
}